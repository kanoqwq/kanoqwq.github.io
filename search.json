[{"title":"Vue笔记","date":"2022-10-10T13:38:06.724Z","url":"/2022/10/10/Vue%E8%AE%B0%E5%BD%95/","categories":[["undefined",""]],"content":"Vue笔记简介 Vue是一个动态构建用户界面的渐进式 Javascript 框架 特点 遵循mvvm模式 编码简洁，体积小，运行效率高，适合移动&#x2F;pc 端开发 它本身只关注UI，也可以引入其他第三方库开发项目 浅尝一下引入Vue.js HTML容器： Vue脚本： Vue的工作条件 想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象 root容器里的代码依然符合html的规范标准，只是混入了vue的一些语法 root容器里的代码被称为Vue模板 一个容器对应一个Vue实例，反之亦然，Vue实例配合组件一起使用 &#123;&#123;&#125;&#125;中需要写的是js表达式，且变量可以自动读取到data中所有的属性 一旦data中的数据发生改变，模板(页面)中的目标也会自动更新 模板语法插值语法插值语法直接在html标签体内使用Vue插值模板，填入data中的属性即可 指令语法 指令语法以 v- 开头，用于解析标签（包括标签属性，标签体内容，绑定事件等） 举例 (v-bind)使用v-bind:来模板化href属性 有时，v-bind: 也可以简写为 : 总结：标签体内用插值语法，标签属性用指令语法 数据绑定由于v-bind是单向的数据绑定，只能通过对象传递到DOM 有了单向数据绑定这个概念，那就一定会有双向数据绑定 双向数据绑定使用：v-model: 注意，以下代码是错误的 这是因为 v-model 只支持表单类等输入型元素内 v-model:value 可以简写为 v-model 因为 v-model 默认收集的就是value的值 el与data的两种写法el的两种写法： 对象属性 使用实例对象的原型对象上的$mount方法挂载元素 data的两种写法 对象式: 函数式: 注意，函数写法不可以是箭头函数，因为会扰乱this的指向（原本this指向一个Vue对象） &#x2F;&#x2F;函数式可适用于vue组件 MVVM模型 M:模型（Model）: 对应 data中的数据 V:视图（View）: 模板 VM：视图模型（ViewModel）: vue实例对象 数据代理Object.defineproperty 方法 此方法可以设置一个对象的属性,该方法有三个参数，区别于直接赋值，该方法的作用更多，更高级 简单用法： 这样就能给一个对象添加属性了，但是你会发现，这个属性居然不能修改，也不能删除，更不能被遍历出来！ 其实是因为 Object.defineProperty 方法默认创建出来的属性，他的 writable, enumerable, configurable的值都为false. 想要解决无法修改，配置，遍历属性的问题，其实很简单，只需要在第三个参数中指定属性的特征即可： 以上代码配置了可修改，可配置，可被枚举的属性特征，所以是可以遍历且值可以被修改删除 getter与setter如标题所言，JavaScript已经开始逐渐像java&#x2F;c#类这样的面向对象语言靠拢了（喜） 直接看使用方法： 当读取msg属性的时候，get访问器就会自动调用函数获取相应的值，返回的值就是msg属性的值修改(set访问器)也是一样，有java&#x2F;C#类语言的基础会更好理解 这样，通过get访问器就可以实现代理msg变量了，实现了数据的双向&#x2F;单向同步 总结：Object.defineProperty 是一个比较高级的给对象添加属性的方法，不仅增加了对象属性的安全性，也可以让我们更灵活使用对象中的属性,更重要的是 这个方法可以设置访问代理，Vue的数据双向绑定就是依照这个方法构建的 数据代理实例我们可以通过一个简单的例子来实现数据代理： Vue中的数据代理 Vue中的数据代理： V通过vm对象来代理data对象中属性的操作读和写 Vue中数据代理的好处： 更加方便操作data中的数据 基本原理： 通过Object。defineProperty() 把data对象中所有的属性添加到vm上，为每一个添加到vm上的属性，都指定一个getter&#x2F;setter 在里面进行读写data中对应的属性 原理图 示例代码 事件处理事件的基本使用 使用v-on:xxx 或 @xxx 绑定事件，其中xxx是事件名 事件的回调需要配置在methods对象中，最终会在vm上 methods中配置的函数不能使用箭头函数，会造成this指向错误 methods中配置的函数，都是被Vue所管理的函数，this的指向是 vm 或 组件的实例对象 @click 中的字符串可以使用函数写法进行传参,@click=&quot;fun&quot;和@click=”fun($event)“是一样的 函数传参的时候如有多个参数，会造成event无法使用，可以在实参列表中，添加$event 进行占位，就可以使用了 代码演示 事件修饰符Vue中的事件修饰符： prevent：阻止默认事件（常用） stop：阻止事件冒泡（常用） once：事件只触发一次（常用） capture：使用事件捕获模式 self：只有event.target 是当前操作的元素才会触发事件 passive：事件的默认行为是立即执行，无需等待事件回调即可执行完毕 注意，事件修饰符是可以连用的 比如 @click.stop.prevent 先阻止冒泡。再阻止默认行为 键盘事件 常用按键别名： 回车 enter删除 delete （删除和退格都行 退出 esc空格 space换行 tab （特殊，必须配合keydown） 上 up 下 down 左 left 右 right Vue未提供别名的按键，可以使用按键原始值的key值绑定，但要注意要转为 keybab-case 短横线小写命名 系统修饰键（特殊） ctrl alt shift 等 配合keyup使用：按下修饰键的同时，再按下其他键，随后释放，事件才能触发 配合keydown使用，正常触发事件 可以使用keyCode指定具体的按键（不建议） Vue.config.keyCodes.自定义按键名&#x3D;键码，可以自定义按键别名 可以利用修饰符连写的特性，进行组合键的侦听 计算属性 定义：要用的属性不存在，要通过已有的属性计算得来。 原理：底层借助了Object.defineproperty方法提供的getter和setter get函数什么时候执行？ 初次读取时会执行一次 当依赖的数据发生改变的时候会被再次调用 优势：与methods实现相比，内部有缓存机制，效率更高，调试方便 注意： 计算属性最终会出现在vm上，直接读取使用即可 如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生变化（firstname、lastname） 代码演示 此外，fullname还有一种简写形式： 可以把属性写成一个函数，函数名就是属性名（es6）函数体默认就有getter的作用 注意！！ 不要把fullname理解为一个函数了，它本身还是一个属性，函数只是负责计算返回结果，在模板内只需要写属性名即可！！！ 监视属性watch 当被监视的属性变化时，回调函数自动调用，进行相关操作 监视的属性必须存在，才能进行监视操作 监视的两种写法 new Vue 时传入 watch配置 通过vm.$watch(‘属性名’，配置) 代码演示 这里有一个小问题注意：当模板里不使用info变量的时候，点击切换天气，vue开发者工具里的变量显示可能不会更新，但vm内属性实际是更新了的 深度监视看完了监视属性的简单使用，这时候我会提出一个需求，那就是，如果data属性内有一个对象，我们该怎么监视该对象里面的特定属性呢？ 监视多级结构中某属性的变化答案是使用 ’对象名.属性名‘：{监视配置} 看代码： 还原成原始写法，就可以使用 点. 来进行单个数据的监视了，也就是深度监视 这样就可以监视多级结构中的某个属性的变化了 深度监视的简易写法如果监视属性里面的语句很简单，就可以使用简易写法： 外部写法也是如此： watch 对比 computedcomputed和watch的区别： computed能完成的功能，watch都可以完成 watch能完成的功能，computed不一定能完成，例如，watch可以执行异步操作 重要的两个小原则： 所被vue管理的函数，最好写成普通函数，这样this的指向才会是vm 所有不会被vue所管理的函数，（定时器，ajax回调）。最好写成箭头函数，这样this指向才是vm 比如下面的姓名案例，用watch实现： 以上代码，会发现我在firstname的处理函数内写了一个定时器，达到了数据更改之后一秒后才执行更改的目的 绑定样式绑定class样式在vue中，绑定class的方式是使用 v-bind来动态处理class样式的 一共有三种方式： 字符串写法，适用于：样式类名不确定 ，需要动态指定 数组写法，适用于：样式类名不确定 ，个数也不确定，名字也不确定，需要动态指定 对象写法，适用于：样式类名确定 ，个数也确定，名字也确定，需要动态决定用不用 代码： 绑定style样式绑定style样式的方法和绑定class样式大同小异 使用 :style=&quot;styleObj&quot; 进行绑定 对象名可以使用驼峰命名的css属性 fontSize: &#39;44px&#39; 也可以是原始css属性，但需要加上引号 &#39;font-size&#39;: &#39;44px&#39; 代码演示 条件渲染1.v-if写法： v-if&#x3D;”表达式” v-else-if&#x3D;”表达式” v-else&#x3D;”表达式” 适用于：切换频率较低的场景 特点：不展示DOM元素直接被移除 注意：v-if可以用：v-else-if ，v-else一起使用，但中间不能有元素打断 2.v-show写法：v-show&#x3D;”表达式“ 适用于：切换频率较高的场景 特点：不展示dom元素，未被移除，仅仅是使用样式隐藏掉 注意：使用v-if时候，元素可能无法被获取到，但是使用v-show是一定可以获取到的 v-if可以配合template模板使用 代码演示 v-for 指令v-for指令可以用来循环遍历对象、数组、字符串、数字 到相应个数的标签中 作用、语法： 用于展示列表数据 语法：v-for=&quot;(item,index) in xxx&quot; :key=&quot;yyy&quot; 可遍历： 数组、对象、字符串、数字 注意：只要你使用了遍历语法，你就必须要使用key这个关键字,给每一个li设定唯一的标识 格式：:key=&quot;xxx“ 代码演示 v-for中key的作用与坑 key在v-for中扮演者极为重要的角色，key是vue作为判断数据的唯一性的重要标识 所以，key的唯一性成了一个非常重要的前提保证 这里就要提一下Vue在生成数据的时候的步骤了： 首先vue会在渲染页面前，在计算机内存中计算并生成一个虚拟DOM，然后才会渲染成真实DOM文档到页面上 如果需要在相同的地方进行重新渲染，Vue就会依次对比新数据和之前的虚拟DOM数据是否一致，如果发现旧数据有一致的地方，则会复用旧的虚拟DOM缓存渲染的真实DOM，以提高渲染效率，如果不一致，则会按照新dom来重新渲染 既然是依次对比，所以，这里就会牵扯到顺序问题，vue是按照key进行顺序遍历对比的，所以，key一定要是一个唯一的值！！！ 要点归纳 虚拟DOM中key的作用： key是虚拟dom对象的标识，当状态中的数据发生变化时，Vue会根据新数据生成“新虚拟dom”随后Vue进行“新虚拟dom” 与 ”旧虚拟dom“ 的差异比较，规则如下： 对比规则： 旧虚拟DOM中找到了与新的虚拟DOM相同的key 若虚拟DOM中的内容没有改变，则会直接复用之前的真实dom 若虚拟DOM中的内容改变了，则会生成新的真实DOM，随后替换掉页面中之前的真实DOM 旧虚拟DOM中未找到与新虚拟DOM相同的key 创建真实的DOM，随后渲染到页面 用index作为key可能会引发的问题： 若对数据进行：逆序添加，逆序删除等破坏顺序的操作： 产生没有必要的真实DOM更改 &#x3D;&gt; 界面没有问题，但是渲染效率降低 如果结构中还包括输入类的dom 会产生错误的DOM更新 &#x3D;&gt; 界面有问题，顺序错乱 开发中如何选择key？ 最好使用每条数据的唯一标识作为key，比如id，手机号，身份证号，学号等唯一值 如果不存在对数据的逆序添加、逆序删除等破坏顺序的操作，仅用于渲染列表用于显示，使用index作为key是没有问题的 错误示例 点击之前： 点击之后 : 你会发现，老六旁边的输入框本应该是空的，结果变成了张三，导致下面的输入框全都错了一位 这是因为：Vue在对比新老虚拟DOM的时候，发现张三在index 0的位置，无法渲染，但是旁边的输入框在虚拟DOM中都是空的，Vue则会复用之前的实际DOM，然后继续往后依次比对，发现每一个的姓名和index都对不上，所以只能使用新虚拟DOM重新渲染名字了，但是，输入框在新老虚拟DOM中，都是空的，Vue就会误以为可以直接复用，就会把前三个复用掉，最后才会渲染新的input元素到最后 这里的主要问题就是，index不是唯一的，修改DOM树的时候容易造成查找不正确，从而进行错误的操作 解决方法把 :key=&quot;index&quot; 替换为 :key=&quot;i.id&quot;即可 或者在这个项目例子里，没有必要非要把老六放在第一位，可以使用push方法插入数据到数组尾部，这样就不会打乱index的标号顺序了 使用列表过滤实现简单搜索与排序基本原理就是，使用计算属性于filter，sort函数 切记，计算属性执行的条件是：页面刚加载时和依赖数据发生变化时 Vue数据侦测实现类似vue的简单数据检测代码演示 不完善的地方：无法找出数组中的对象并赋予getter setter , 多层对象也一样 使用Vue.set方法新增响应式属性首先得注意的是： 这个set方法只能给vue data里面某个对象增加属性!!!也就是要操作的对象不能是Vue实例，或者Vue实例的根数据对象（data、_data） 语法 例子 数组更新检测Vue将被监听的数组的变更方法进行了包装，所以也可以触发网页元素更新，方法包括： push() pop() shift() unshift() splice() sort() reverse() 注意：使用下标索引直接修改数组数据是不会触发视图更新的！！！ 错误示范 上面的操作是不会生效的（ 对于非修改性质的方法，比如filter() ，过滤完成后可以直接替换赋值掉原对象 代码演示 此外，除了可以用上面提到的几个方法操作数组之外，其实也可以使用Vue.set方法进行变更数据: 总结Vue监视数据的原理： Vue会监视data中所有层次的数据 如何检测对象中的数据 通过setter实现监视，且要造new Vue 时就要传入要监测的数据 对象中后追击啊的属性，Vue默认不做响应式处理 如需给后添加的属性做响应式，请使用如下API vue.set(target,propertyName/index,value) vm.$set(target,propertyName/index,value) 如何监测数组中的数据？ 通过包装数组对应更新元素的方法来实现，本质就是 调用原生对应的方法对数组进行更新 重新解析没模板，进而更新页面 vue修改数组中某一个元素一定要使用支持的方法 API: push , pop , shift , unshift , splice , sort , reverse Vue.set 或者 vm.$set 特别注意的是：Vue.set 和 vm.$set 不能给vm或者vm的根数据对象添加属性！ 对于非修改性质的方法，比如filter() ，过滤完成后可以直接替换赋值掉原对象 使用v-model收集表单数据要点： 若：&lt;input type=&quot;text&quot;&gt; 则v-model收集的是value的值。若：&lt;input type=&quot;radio&quot;&gt; 则v-model收集的是value的值，且要给标签配置value值若：&lt;input type=&quot;checkbox&quot;&gt; : 没有配置input的value属性：，那么收集的就是checked（布尔值） 配置input的value属性： v-model的初始属性就是非数组，那么收集的就是checked（布尔值） v-model的初始值是数组，那么收集的就是value组成的数组 备注：v-model的三个修饰符： lazy：失去焦点再收集数据 number：输入字符串转换为有效数字 trim：输入首尾空格过滤 代码演示 v-text 指令作用：向其所在的节点中渲染文本内容 与插值语法的区别：会替换标签里面现有的文本 演示 v-html 指令作用：向指定节点中渲染包含html解构的内容，使用上和v-text没有太大区别，但还是有点 与插值语法的区别： v-html会替换掉节点中所有内容，插值语法则不会 v-html可以识别html结构 ！严重注意：v-html会有安全性的问题： 在网站上动态渲染任意HTML都是非常危险的，容易导致xss攻击 一定要在可信任内容上使用v-html 永远不要在用户提交的内容上使用！ 演示 v-cloak指令 本质是一个特殊属性，Vue实例创建完毕并接管容器之后，会删掉v-cloak属性 使用css配合v-cloak可以解决网速慢时候页面展示出的问题 演示 v-once指令 v-once所在的节点在初次动态渲染之后，就视为静态内容了， 以后数据的改变不会引起v-once所在的结构的更新，可以用于优化性能 代码演示 v-pre指令 跳过其所在节点的编译过程 可利用它跳过，没有使用指令的语法，没有使用插值与法的节点，会加快编译 代码演示 自定义指令我们可以使用directives编写自定义指令 directives内可以有两种写法： 函数式，属性是函数，适用于处理简单一点的事务 对象式，里面有三个函数：bind，inserted，update 指令与元素成功绑定时会执行bind 指令被所在元素插入页面时会执行inserted 指令所在的模板被重新解析时会执行update 注意，以上函数的this指向都为window注意，指令定义的时候不加 v- 但使用的时候要加 局部写法: 全局写法: Vue.directive(&#39;指令名&#39;,&#123;bind，inserted，update&#125;)或 Vue.directive(&#39;指令名&#39;,回调函数) big函数何时会被调用？ 指令与元素成功绑定时(绑定时候是虚拟dom状态，还没有放入页面) 指令所在的模板被重新解析时 特别注意！！！ 自定义指令不能使用驼峰名称或者大写字母，因为Vue会把指令名上所有大写字母转成小写字母！！，推荐使用-（需要还原为带引号的属性名）或者_作为分隔符 例子 定义一个v-big指令，和v-text功能类似，但会把绑定的数值放大十倍 定义一个v-fbind指令，和v-bind功能类似，但可以让其所绑定的input元素默认获取焦点 当我们想要在一开始的时候获取input元素的焦点，除了可以在input标签里面添加autofocus之外，我们还可以使用自定义指令，但是自定义指令如果写成函数式，就会出现页面加载后，自动对焦不起作用问题： 其原因在于：一开始dom并没有先渲染出来，只有点击+1后才会生效，因为元素已经在页面里面，所以执行focus就会生效 正确写法： 生命周期 Vue的生命周期中一共要执行很多重要的函数，mounted函数则是其中的一个 简介 生命周期又叫生命周期回调函数、生命周期函数，生命周期钩子 Vue在关键时刻帮我们调用的一些特殊名称的函数 生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的 生命周期函数中的this指向的是VM 或 组件的实例对象 流程图 分析生命周期vue实例的整个生命周期分别要执行如下几组函数： beforeCreate( ) 和 created( ) beforeMount( ) 和 mounted( ) beforeUpdate( ) 和 updated( ) beforeDestroy( ) 和 destroyed( ) 每个生命周期函数的作用beforeCreate函数 这个阶段初始化生命周期和事件，但是代理并没有开始在这个阶段，无法通过vm访问倒data中的数据，method中的方法 created函数 生命周期和事件初始化完毕在这个阶段，可以通过vm访问倒data中的数据，methods中的方法 beforeMount函数 在这个阶段，页面呈现的是未经Vue编译的DOM结构，故而在这期间，所有对dom的操作最终都是无效的此时会发现，页面的基本结构已经渲染到页面上了，但是插值语法等并没有进行解析这是因为在这期间，Vue并没有将真实DOM放到页面上，此时的DOM还是虚拟的 mounted函数 Vue完成模板解析并把真实DOM元素放入页面后（完成挂载）会调用一个名叫mounted的函数这个函数整在个Vue的生命周期中只调用一次此时页面中呈现的是经过VUe编译的ODM，对DOM的操作均有效（但不推荐） 至此初始化的过程就结束了p.s: 这里一般可以进行：开启定时器，发送网络请求，订阅消息，绑定自定义事件，等其他初始化操作 beforeUpdate函数 当Vue准备发生响应式变化的时候，会触发beforeUpdate系列函数此时，数据是新的，但页面是旧的即：页面尚未和数据保持同步 updated函数 当数据更新操作执行完毕后，会触发updated系列函数此时，数据是新的，页面也是新的即：数据和页面保持同步 beforeDestroy函数 这个函数是在Vue实例销毁之前所执行的此时，vm中所有的 data,method 指令等等都处于可用状态，马上要执行销毁作业，但是在这里所有的对this的操作都不会触发页面更新了一般在这个阶段可以做：关闭定时器，取消订阅消息，解绑自定义事件等操作 destroyed函数 Vue销毁实例之后会执行destroyed回调函数此时vm已经销毁 以上就是Vue实例的整个生命周期了 生命周期函数演示 总结生命周期常用的生命周期钩子： mounted：可以发送Ajax请求、启动定时器、绑定自定义事、订阅消息等【初始化操作】 beforeDestroy：清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】 关于销毁Vue实例 销毁后借助Vue开发者工具不会看到任何信息 销毁后自定义事件会失效，但是原生DOM事件依旧有效（vue2.7版本之后无效） 一般不会在beforeDestory中操作数据，因为那样不会出发数据&#x2F;页面更新流程了 Vue组件化编程传统方式与组件化方式的区别传统方式编写应用的问题： 依赖关系混乱，不好维护 代码复用率不大，耦合性较高 组件化编程方式的优点： 依赖关系清晰，方便维护 代码复用率非常高，组件之间互不影响 组件的概念 所谓的组件就是实现应用中局部功能代码和资源的集合 模块与组件、模块化与组件化模块理解：向外提供特定功能的 js 程序，一般为一个js文件 使用原因： js文件多而杂 作用：复用js，简化js的编写，提高js运行效率 组件理解：用来实现局部（特定）功能效果的代码集合（html&#x2F;css&#x2F;js&#x2F;image） 使用原因：一个界面的功能很复杂 作用：复用编码，简化项目编码，提高运行效率 模块化当应用中的js都以模块来编写的，那这个应用就是一个模块化的应用 组件化当应用中的功能都是多组件的方式来编写的，那这个应用就是一个组件化的应用 非单文件组件与单文件组件非单文件组件一个文件中包含有N个组件 单文件组件一个文件中只包含有一个组件 非单文件组件编写Vue使用组件的三大步骤 定义组件（创建组件） 注册组件 使用组件（写组件标签） 如何定义？使用Vue.extend(options)*创建，其中options和new Vue(options) 时传入的options几乎一样，但也有区别 区别如下： el不要写，因为最终左右的组件都要经过一个vm管理，由vm中的el决定服务哪个容器。 data必须写成函数，为什么？ — 避免组件被复用时，数据存在引用关系，使用函数形式，其中的return可以自动复制对象（深拷贝） 备注1：使用template可以配置组件html解构 备注2：vue.extend()方法其实是vue的一个构造器,继承自vue 使用基础 Vue 构造器,创建一个“子类”。参数是一个包含组件选项的对象。 如何注册？ 局部注册：靠newVue时候传入的components选项 全局注册：靠Vue.component(‘组件名’,组件); 编写组件标签使用 &lt;组件名&gt;&lt;/组件名&gt; 来在页面上引用组件标签 代码示例 组件的命名方法对于单个单词组成：首字母大写即可 对于多单词组成： 全部小写，使用短横线 ’ - ‘ (kebab-case命名) 连接 ：my-component 每一个单词的首字母大写 (camelCase命名) ：MyComponent （只能在脚手架环境中使用） 备注： 组件名尽可能回避原生的标签名，例如：h2、H2 都不可以 可以使用name配置项指定组件在开发者工具中呈现的名字 关于组件标签： 第一种写法：&lt;MiniKano&gt;&lt;/MiniKano&gt; 第二种写法：&lt;MiniKano/&gt; 备注：不使用脚手架时， 会导致后续组件无法渲染 一个简写形式： const school = Vue.extend(options) 可简写为: const school = options可以简写是因为最后vm中的components会判断传入的是extends过的还是原对象，从而做出不同的反应 组件的嵌套只需要注意一点：想嵌套到哪个组件就放到哪个组件内 代码示例 以上代码组件结构如下： &lt;root&gt; &lt;app&gt; &lt;MiniKano&gt; &lt;hello&gt; 总结：被嵌套属性需要在template属性中写上嵌套者的组件标签，components中写上嵌套者的组件名即可完成嵌套操作 VueComponent构造函数关于VueComponent： school组件本质是一个名为VueComponent的构造函数，且不是程序员定义的，是Vue.extend生成的。 我们只需要写&lt;school/&gt; 或 &lt;school&gt;&lt;/school&gt;,Vue解析时会帮我们创建school组件的实例对象即Vue帮我们执行的：new VueComponent(options) 特别注意：每次调用Vue.extend。返回的都是一个全新的VueComponent！！所以每个标签组件就可以复用，因为他们都是独立的个体实例对象 关于this的指向： 组件配置中： data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【VueComponent实例对象】 new Vue()配置中 data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【Vue实例对象】 VueComponent的实例对象，以后简称vc （组件实例对象）Vue的示例对象，以后简称vm VueComponent内部实现如果我们创建了多个组件，分别输出组件的值： 结果都为 但是从Vue.extend的源码来看，这两个VueComponent并不是同一个函数 因为Vue.extend源码是这样写的: 大致代码如下： 每次调用Vue.extend的时候，都会创建一个新变量用于接收新构造函数所以每个组件的VueComponent都成为了独立的个体直到需要渲染到页面时候，就会执行这些构造函数 如何获取Vue所管理的组件实例对象 可以使用vm.$children属性获取 vm.$children属性返回的是一个数组，里面有vm管理的组件实例 例： 备注：如果组件里面也有子组件，那这个组件的$children属性里面就会显示存放子组件 vm与vc的本质区别vm与vc相比： vc没有独立的el属性 vc的data必须写成函数式 vc是VueComponent的实例对象，而vm是Vue的实例对象 组件的一个重要的内置关系概述 一个重要的内置关系：VueComponent.prototype.proto&#x3D;&#x3D;&#x3D; Vue.prototype 为什么要有这个关系：让组件实例对象（vc）可以访问到Vue原型上的属性和方法 这涉及到原型链的问题，我们知道，VueComponent 和 Vue 实例化之后两者的内置的方法和属性其实都大同小异，其中的关键在于，Vue复用了一些方法与属性：指 通过更改原型指向的方式共享Vue上的一些属性和方法 这种方式也叫 原型链继承 代码演示： Vue的原型链大致为： Vue –&gt; Vue的原型对象 –&gt; Object的原型对象 –&gt; null VueComponent的原型链大致为： VueComponent –&gt; VueComponent的原型对象–&gt; Vue的原型对象 –&gt; Object的原型对象 –&gt; null 图解 单文件组件的编写简介单文件组件文件的扩展名是.vue 文件内可以写三种标签： &lt;template&gt;标签 ,用于填写预解析模板，也就是组件的结构 &lt;script&gt;标签，用于填写组件交互相关的代码（数据，方法等） &lt;style&gt;标签，用于填写组件的样式 注意：多个vue单文件组件，最终会汇总于App.vue文件中，方便统一管理 script标签中由于填写的是组件相关的交互代码，故需要使用export向外暴露需要的变量 目录结构一般一个单文件组件写成的工程的文件树是这样的 Root School.vue Student.vue App.vue main.js index.html 其中： App.vue汇总了所有的组件 main.js内实例化了vm index.html提供了网页基础结构 代码演示School.vue Student.vue App.vue main.js index.html 不过，你会发现，以上代码根本执行不了，原因是需要Vue脚手架的支持，脚手架将在下面小节讲，这里只是熟悉一下单文件组件的编写方法（（ Vue脚手架介绍 Vue脚手架又叫 Vue CLI（Command Line Interface） 安装第一步：安装Node.js 后，在命令行直接输入 第二步：切换到你要创建项目的目录，然后使用命令 第三步：启动项目 目录结构及文件描述目录树如下： 其中： babel.config.js 是babel的控制文件，用于将es6语法向下转换为es5的兼容语法，一般不需要做改动 package.json 是包的管理文件，用来记录vue整个工程的名字，版本，主要包，启动参数等 yarn.lock 是yarn的依赖包版本锁，用于控制依赖包及依赖包版本 public 目录用于存放静态html资源，也是网页的入口 src 目录用于存放源码，下面细说： src 根目录一般存放 main.js App.vue asserts目录里面主要是存放一些前端资源文件，如图片媒体等 components目录主要存放Vue的组件 README.MD 是说明文档啦~ P.S:如果安装了lint工具的话，记得在编写程序的时候不要使用它，不然会影响编程效率（ 执行vue serve执行了serve操作之后，vue首先就会执行main.js 之后会按照流程创建vm。引入组件等操作 注意：run 之后 可能会有lint的报错导致无法启动，为了方便，可以直接在vue.config.js里面的defineConfig函数对象参数中添加 lintOnSave:false 即可 Render函数问题我们之前在main.js内Vue函数里面是这样写的 但是，当我们使用脚手架打包运行的时候，会提示如下错误 [Vue warn]: You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build.(found in ) 通过提示可知道:现有的vue运行时环境并不能使用模板编译器，可以选择使用render函数，或者使用完整的带解析器的vue运行环境 因为我们引用的时候直接写了import Vue from &#39;vue&#39;在vue的源代码内其实是引用了 dist/vue.runtime.esm.js(ECMAScript Module) p.s:不引入完整的vue执行和渲染效率会高一点，占用空间会低一点 解决方法 使用完整版的Vue：import Vue from &#39;vue/dist/vue&#39; 使用render函数 Render函数原理render函数包含一个参数，类型为function 默认是createElement函数 箭头函数写法： 关于不同版本的vue vue.js 与 vue.runtime.xx.js的区别： vue.js是完整版的Vue，包含：核心功能+模板解析器 vue.runtime.xxx.j是运行版的Vue，只包含：核心功能，没有模板的解析器 因为vue.runtime.xxx.js没有模板解析器，所以不能使用template配置项，需要使用render函数接收到的createElement函数去指定具体内容 修改默认配置Vue脚手架隐藏了所有的 webpack 相关的配置，如果香查看具体的webpack的配置，请执行: vue inspect &gt; output.js 可以修改 这个对象来自定义入口函数的名字 但直接修改这一句显然是不会奏效的，需要修改vue.config.js vue.config.js 是一个可选的配置文件，如果项目的(和package.json同级的)根目录中存在这个文件，那么它会被@vue&#x2F;cli-service自动加载。你也可以使用package.json中的 vue字段，但是注意这种写法需要你严格遵照JSON的格式来写。 如果我们想要修改main.js入口文件的名字，需要进入vue.config.js中的pages对象中进行修改： 其他配置项可以i对脚手架进行个性化定制，详见：配置参考 | Vue CLI (vuejs.org) 使用ref标记DOM有些时候我们需要操作DOM，但在Vue中使用原生DOM操作指令显得不是太友好，所以Vue为我们提供了一个比较好用的操作DOM的方法：ref标记 只需要给template标签中的元素添加一个ref属性即可： 然后就可以使用vc中的：$refs 进行控制DOM等操作 但这里有个需要注意的点：如果给组件标签打上ref属性，那$refs的输出则是该组件标签与之对应的组件实例对象： ref总结： ref属性被用来给元素或子组件注册引用信息 （id的替代者） 应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象（vc） 使用方式： 打标识： 获取： this.$refs.msg 配置项porps功能： 让组件接收外部传过来的数据 传输数据： &lt;Demo name=&quot;xxx&quot;/&gt; 接收数据： 第一种方式（只接收）： props:[&#39;name&#39;] 第二种方式（限制类型） 第三种方式（限制类型，限制必要性，指定默认值） 备注：props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发生警告，若业务需求需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据。 混入（mixin）功能： 可以把多个组件公用的配置提取成一个混入对象 使用方式： 第一步定义混合，例如： 第二步使用混入，例如： 全局混入：Vue.mixin(mixin) 局部混入：mixins:[mixin] 代码示例： 准备混入文件（mixin.js） 局部混入(组件.vue)： 全局混入(main.js)： 插件功能：用于增强Vue 本质：包含一个install方法的一个对象，install的第一个参数是Vue ，第二个以后的参数是插件使用者传递的数据。 定义插件： 使用插件：Vue.use(插件名) scoped（局部）样式在编写组件的时候，我们在每个组件中的style样式里面编写很多自定义样式，但是每个样式名字很容易重合，如果名字重合了，会出现样式覆盖的问题。 比如： 在student.vue中，编写了demo样式，在school.vue中同样也编写了demo样式，而且在app.vue中先引入了school，后引入student，就会出现后者的样式覆盖掉前者的同名样式的问题 想要解决这个问题的话，需要使用一个全新的配置项： scoped 用法：只需要在style标签中添加即可 样式块兼容less想要在style块中兼容less，那么就需要在style标签里面添加 lang属性，写法如下： 注意：直接保存可能会报错，因为没有安装webpack的 less-loader插件 使用 npm i less-loader即可 *不写lang属性默认就是css 组件化编码流程（通用） 实现静态组件：抽取组件。使用组件实现静态页面效果 展示动态数据： 数据的类型、名称是什么？ 数据保存在哪个组件？ 交互——从绑定事件监听开始 TodoList案例代码下载： 总结案例 组件化编码流程： 拆分静态组件：组件要按照功能点拆分，命名不要与html元素冲突 实现动态组件：考虑好数据的存放位置，数据是一个组件再用，还是一些组件再用： 一个组件再用，放在组件自身就行 一些组件再用：放在他们的共同的父组件上（状态提升） 实现交互：从绑定事件开始 props适用于： 父组件 &#x3D;&#x3D;》 子组件 通信 子组件 &#x3D;&#x3D;》 父组件 通信（要求父先给子一个函数） 使用v-model时要切记：v-model绑定的值不能是props传过来的值，因为props是不可以被修改的 props传过来的若是对象类型的值，修改对象中的属性时Vue不会报错，但不推荐这么做 可以通过本地存储进行保存状态 组件的自定义事件 一种组件间通信的方式，适用于：子组件&#x3D;&#x3D;&#x3D;》 父组件 使用场景：A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件（事件的回调在A中）&#x2F; 解绑自定义事件： 第一种方式，在父组件中：&lt;Demo @MiniKano=&quot;test&quot;/&gt; 或者 &lt;Demo v-on:MiniKano=&quot;test&quot;&gt; 第二种方式，在父组件中: 若想让自定义事件只能触发一次，只需要加上once修饰符或者$once方法 触发自定义事件：this.$emit(&#39;MiniKano&#39;,传参) 解绑自定义事件:this.$off(&#39;MiniKano&#39;) 不写参数则为全部解绑，多参数需写成数组形式 组件上也可以绑定原生DOM事件，但需要native修饰符，例如&lt;Student @click.native=&quot;show&quot;/&gt; 注意：通过this.$refs.xxx.$on(xxx,回调函数)绑定自定义事件时，回调要门配置在method中，要么使用箭头函数，总是需要注意this的指向 P.S: 组件的自定义事件可以在Todolist中用，替换掉全选等方法 全局事件总线全局事件总线(Global Event Bus)：可以实现任意组件之间的互相通信，数据传递 全局事件总线，其实不是一个特定的接口或者方法，而是前人总结出来的一种实现组件间互相通信的结构 原理与使用由于Vue有一个内置的关系：VueComponent.prototype.__proto__ === Vue.prototype我们可以直接利用这个内置关系，在Vue.prototype上创建一个总线的载体$bus（一般为vm的实例对象） 安装全局事件总线： 使用事件总线： 1.接收数据：A组件想要接收数据，则在A组件中给$bus绑定自定义事件，事件的回调留在A组件自身 2.提供数据：this.$bus.$emit(&#39;xxx&#39;,数据) P.S:最好在beforeDestroy钩子中，用$off去解绑当前组件所用到的事件 小结全局事件总线，其实就是在普通的自定义事件上，稍作修改，把事件绑定在了一个所有组件都能访问的原型对象（VM）上而已 消息订阅与发布（pubsub）概念pubsub 是一种组件间通信的方式，适用于任意组件间通信。 使用步骤 安装pubsub：npm i pubsub-js 引入：import pubsub from pubsub-js 接收数据：A组件想要接收数据，则在A组件中订阅消息，订阅的回调留在A组件自身 提供数据：pubsub.publish(&#39;xx&#39;,数据) 最好在beforeDestroy钩子中，用pubsub.unscrible(pid)去 取消订阅 这个组件能实现类似全局事件总线的功能，但是相比全局事件总线来说，需要手动安装，没有全局事件总线的原生优势 $nextTick这个是在TodoList项目中使用的一个新的方法,是生命周期里的钩子 语法：this.$nextTick(回调函数) 作用：在下一次DOM更新结束后执行指定的回调方法 nextTick主要是用于处理数据动态变化后，DOM还未及时更新的问题，用nextTick就可以获取数据更新后最新DOM的变化： 在Todolist项目中，当我们点击编辑按钮时，会出现一个input框，我们就需要在点击编辑按钮后立马获取input的焦点,如果直接在编辑按钮的点击事件中focus input框的话，是无效的，因为Vue要先执行完method里面的东西之后，才会更新DOM文档 这时候就会想到，可以用异步代码去滞后执行自动对焦。比如定时器 不过使用定时器的话，显然不是很优雅() 当然是有更合理的解决方法的，Vue给我们提供了一个方法#nextTick 用nextTick就可以在模板更新后调用预设的方法： Vue封装的过渡与动画 作用：在插入、更新、或移除DOM元素时，在核实的时候给元素添加样式类名 图示: 写法： 准备好样式： 元素进入的样式： v-enter:进入的起点 v-enter-active：进入过程中 v-rnter-to：进入的终点 元素离开的样式： v-leave:离开的起点 v-leave-active：离开过程中 v-leave-to：离开的终点 样式写法示例： 使用包裹要过度的元素，并配置name属性： 备注：若有多个元素需要过度，则需要使用：，且每个元素都要指定key值： 想让元素默认是显示，可以添加 appear 属性 样式的名字默认是v开头，如果想自定义样式头，可以在标签上加上name属性即可 使用插件控制过渡（animate.css）：首先需要安装插件：npm install animate.css Vue代理当我们在脚手架中编写ajax请求的时候，与服务器通信，有时候会遇到跨域问题 一般的做法就是在后端进行处理，设置响应头，或者使用cors插件进行跨域处理 但我们也可以使用 代理服务器 的方式进行间接的请求 代理服务器请求原理： 因为ajax请求有跨域问题，但是代理服务器与后端服务器之间的通信并不是使用ajax进行传输的，所以自然不会存在跨域的问题 使用方法配置 在vue.config.js中添加一个新属性： 这会告诉开发服务器将任何未知请求 (没有匹配到静态文件的请求) 代理到后端服务器地址。 把需要ajax请求的地址统一换为脚手架的服务器地址： 如果你想要更多的代理控制行为，也可以使用一个 path: options 成对的对象。 注意：有时设置代理的时候，需要去掉请求头 比如上面的&#39;/api&#39; 防止带入到后端服务器造成404使用pathRewrite 重写请求地址，格式：pathRewrite:&#123;&#39;正则表达式&#39;,&#39;替换字符串&#39;&#125; 这样就可以解决跨域ajax请求的问题了 github搜索框案例案例下载：[bdbtn][/bdbtn] Vue-resource注意，此插件已过时 如果不想用axios发送http请求，也可以使用一个Vue插件：Vue-resource 安装： 引入： 使用： slot 插槽 当我们想要在同一个组件里面展示不同内容的时候，除了使用v-if之外，还可以使用插槽 来分发内容 作用：让父组件可以向子组件指定位置插入html结构，也是一种组件间通信方式，适用于 父组件 &#x3D;&#x3D;&#x3D;》子组件 分类： 默认插槽，具名插槽，作用域插槽 默认插槽我们可以通过定义一个&lt;slot&gt;&lt;/slot&gt;来作为一个插槽 使用方法： App.vue Category.vue 具名插槽有时我们需要多个插槽，默认插槽显然已经不能满足多插槽的使用情景，下面将引入具名插槽 使用方法： App.vue Category.vue 作用域插槽理解：数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定，（games数据在category组件中，但使用数据所遍历出来的结构由app组件决定） 2.具体编码： App.vue Category.vue: 总结：这三种插槽可以按照实际情况配合使用 VueXvueX是什么 概念：专门在Vue中实现集中式状态（数据）管理的一个Vue组件，对vue应用中多个组件的共享状态进行集中式管理（读&#x2F;写），也是一种组件间通信的方式，且适用于任意组件间的通信。 什么时候使用VueX 多个组件依赖于同一个状态 来自不同组件的行为需要变更同一个状态 工作原理 上图是VueX的 “状态管理模式”： 这个状态自管理应用包含以下几个部分： state，驱动应用的数据源（公共数据）； view，以声明方式将 state 映射到视图； actions，响应在 view 上的用户输入导致的状态变化（类似中间件）。 其实就是类似于后端开发中的三层结构：视图层 业务层 持久层 工作流程 组件请求数据，使用 dispatch(&#39;name&#39;,&#39;MiniKano&#39;),请求一个变量名(key)为name，值为‘MiniKano’的函数 dispatch函数会到Actions中，这里类似中间件，可以在这里发送后端ajax请求，进行数据处理等操作，之后Actions会执行commit(&#39;name&#39;,&#39;MiniKano&#39;)到Mutations commit函数到达Mutations中，会进行查找key为‘name’对应的函数，在这个函数内，存放了state 中的公共数据，进行Mutate操作，也就是 修改&#x2F;处理 数据 在Mutate操作，修改数据成功时，Vue会渲染修改后的DOM到视图中，这样就完成了修改数据的流程 注意：Actions如果不进行特殊操作，仅仅只是传递数据，可以直接在Vue Component步骤时候直接调用commit(&#39;name&#39;,&#39;MiniKano&#39;) 就可以跳过Actions阶段 搭建VueX环境安装VueX注意：vue2中需要使用VueX的3版本，Vue3中需要使用VueX的4版本 Vue2： Vue3: 使用VueX创建文件:src/store/index.js 在main.js中创建vm时传入store配置项 组件中读取Vuex中的数据：$store.state.sum 组件中修改Vuex中的数据：$store.dispatch(&#39;action中的方法名&#39;,数据) 或者 $store.commit(&#39;action中的方法名&#39;,数据) getters的使用在src/store/index.js中添加getters对象即可 使用getters：$store.getters.属性名 四个map方法的使用mapState方法：用于帮助我们映射state中的数据为计算属性 mapGetters 方法：用于帮助我们映射getters中的数据为计算属性 mapActions方法：用于帮助我们生成actions对话的方法，即：包含$store.dispatch(xxx)函数 **mapMutations方法:**用于帮助我们生成mutations对话的方法，即:包含$store.commit(xxx)函数 备注：mapActions与Mutations使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则参数是事件对象 VueX模块化与namespace目的：让代码更好维护，让多种数据分类更加明确 修改store.js 开启命名空间后，组件中读取state数据 开启命名空间后，组件中读取getters数据 开启命名空间后，组件调用dispatch 开启命名空间后，组件调用commit 求和案例(VueX)代码下载：[bdbtn]求和案例.zip[/bdbtn] Vue-router相关理解vue-router 的理解是一个Vue的插件库，专门用来实现SPA应用 对SPA应用的理解 单页 Web 应用 （single page web application，SPA） 整个应用只有一个完整的页面。 点击页面中的导航链接不会刷新页面，只会做页面的局部刷新。 数据需要通过ajax请求获取。 路由的理解 什么是路由？ 一个路由就是一组映射关系（key - value） key为路径，value可能是function或component 路由的分类 后端路由： 理解：value 是 function，用于处理客户端提交的请求 工作过程：服务器接收到一个请求时，根据请求路径找到匹配的函数来处理请求，返回响应数据 前端路由： 理解：value 是 component，用于展示页面内容 工作过程：当浏览器路径改变时，对应的组件就会显示。 路由的基本使用 安装vue-router，命令npm i vue-router(vue2安装 vue-router@3) 引用并应用插件：vue.use(VueRouter) 编写router配置项（/src/router/index.js）： 在main.js中注册路由 实现切换（active-class可配置高亮样式） 指定展示位置 注意: 路由vue组件一般不放到component文件夹中，而是单独放在一个叫pages的文件夹中 通过切换，’隐藏 ‘了路由组件，默认是被销毁掉的，需要的时候再去挂载 每个组件都有自己的$route属性，里面存储着自己的路由信息 整个应用只有一个router，可以通过组件的$router属性获取到 多级路由配置路由规则，使用children配置项： 跳转（需写完整路径） 路由的query参数 传递参数 接收参数 命名路由 作用:可以简化路由的跳转。 如何使用： 给路由命名： 简化跳转： 路由的params参数 配置路由，声明params参数 传递参数 特别注意：路由携带params参数时，若使用to的对象写法，则不能使用path配置项，需要使用name写法！ 接收参数： 路由的props配置作用：让路由组件更方便的接收到参数 接收端只需要添加相应的props参数即可：props:[&#39;id&#39;,&#39;title&#39;] &lt;router-link&gt;的replace属性 作用：控制路由跳转时操作浏览器历史记录的模式 浏览器的历史纪录有两种写入方式：分别为push和replace，push是追加历史记录 replace是替换当前历史记录，默认为push 如何开启replace模式：&lt;route-link replace .......&gt; 即可 编程式路由导航 作用：不借助&lt;router-link&gt;实现路由跳转，让路由跳转更加灵活 具体编码： 前进和后退： 缓存路由组件 作用：让不展示的路由组件保持挂载，不被销毁。 具体编码： 如果想缓存多个组件，可以写成数组形式 两个新的生命周期钩子作用：路由组件独有的两个钩子，用于捕获路由组件的激活状态。 具体名字： actived路由组件被激活时触发。 deactivate路由组件失活时触发。 active deactivate 路由守卫 作用:对路由进行权限控制 分类：全局守卫、独享守卫、组件内守卫 全局守卫： 独享路由守卫（只有前置没有后置） 组件内守卫（千万不要理解为前置或者后置守卫，没有这种说法） 路由器的两种工作模式 对于一个url来说，什么是hash值？ —- #及其后面的内容就是hash值 hash值不会包含在HTTP请求中，即：hash值不会带给服务器 hash模式： 地址中永远带着# 号，不美观 若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法 兼容性较好 history模式： 地址干净美观 兼容性和hash模式相比略差 应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题 切换方法： ElementUI引入 Element你可以引入整个 Element，或是根据需要仅引入部分组件。我们先介绍如何引入完整的 Element。 完整引入在 main.js 中写入以下内容： 以上代码便完成了 Element 的引入。需要注意的是，样式文件需要单独引入。 按需引入借助 babel-plugin-component，我们可以只引入需要的组件，以达到减小项目体积的目的。 首先，安装 babel-plugin-component： 然后，将 .babelrc 修改为： 接下来，如果你只希望引入部分组件，比如 Button 和 Select，那么需要在 main.js 中写入以下内容： Vue3使用vite创建工程 常用 Composition API1.setup函数 理解：Vue3中的一个新配置项，值为一个函数 setup是所有Composition API（组合API）’表演的舞台‘ 组件中所用到的：数据、方法等、均要配置再setup中 setup函数的两种返回值： 若返回一个对象，则对象中的属性，方法，再模板中均可以直接使用（需要注意） 若返回一个渲染函数：则可以自定义渲染内容。 注意点： 尽量不要与Vue2.x配置混用 但setup中不能访问到Vue2.x中的配置（data、methods、computed…） 如有重名，setup优先 setup不是一个async函数，因为返回值不再是return的对象，而是promise，模板看不到return对象中的 属性(但后面讲到了Suspense异步组件的时候会就可以返回Promise或者async形式的setup) 2.ref函数 作用：定义一个响应式的数据 语法: const xxx = ref(initValue) 创建一个包含响应式数据的引用对象（reference对象） JS中操作数据：xxx.value 模板中读取数据:不需要.value,直接&#123;&#123;xxx&#125;&#125;即可 备注： 接受的数据可以是：基本类型、也可以是对象类型 基本类型的数据：响应式依然是靠Object.defineProperty()的get与set完成的 对象类型的数据：内部”求助“了Vue3中的一个新函数— reactive函数 3.reactive函数 作用：定义一个对象类型的响应式数据（基本类型别用他，用ref函数） 语法：const 代理对象 = reactive(被代理对象)接收一个对象（或数组），返回一个代理器对象（Proxy的实例对象） reactive定义的响应式数据是’深层次的‘ 内部基于ES6中的Proxy实现，通过代理对象操作源对象内部数据都是响应式的 4.Vue3.0中的响应式原理vue2.x的响应式 实现原理： 对象类型：通过Object.defineProperty()对属性的读取，修改和拦截（数据劫持） 数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包装） 存在的问题： 新增属性、删除属性，界面不会更新（没有响应式） 直接通过下标修改数组，界面不会自动更新 Vue3.0的响应式 实现原理： 通过Proxy（代理）: 拦截对象中任意属性的变化，包括属性值的读写、属性的添加与删除等 通过Reflect（反射）：对被代理对象中的属性进行操作。 MDN文档中有描述Proxy和Reflect的信息，可以去看看 reactive对比ref 从定义数据角度对比 ref用来定义：基本类型数据 reactive用来定义：对象（或数组）类型的数据 备注：ref也可以用来定义对象（或数组）类型的数据，它内部会自动通过reactive转换为代理对象 从原理角度对比： ref通过Object.defineProperty()的get与set来实现响应式（数据劫持） reactive通过使用 proxy 来实现响应式（数据劫持），并通过Reflect操作源对象内部的数据 从使用角度来对比： ref定义的数据：操作数据需要.value 读取数据时模板中直接读取，不需要·value reactive定义的数据：操作数据与读取数据：均不要.value setup的两个注意点 setup执行的时机 在beforeCreate之前执行一次，this是undefined setup的参数 props：值为对象，包含：组件外部传递过来，且组件内声明接收了的属性 context：上下文对象 attrs：值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性，相当于this.$attrs slots：收到的插槽内容，相当于this.$slots emit：分发自定义事件的函数，相当于this.$emit 计算属性与监视 computed函数 与vue2.x中的computed配置功能一致 写法 watch函数 与vue2.x中的watch配置功能一致 两个小坑 监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视（deep配置失效）。 监视reactive定义的响应式数据中某个属性时：deep配置有效 &#96;&#96;&#96;javascript&#x2F;&#x2F;情况一：监视ref所定义的响应式数据watch(sum,(newValue,oldValue)&#x3D;&gt;{console.log(‘sum变化’,newValue,oldValue);},{immediate:true}) &#x2F;&#x2F;情况二：监视ref定义的多个响应式数据(使用数组)&#x2F;&#x2F;如果是reactive的对象设置的属性，默认会强制开启深度监视（deep配置无效），无需设置，也不能关掉深度监视watch([sum,msg],(newValue,oldValue)&#x3D;&gt;{console.log(‘sum变化’,newValue,oldValue);},{immediate:true}) &#x2F;&#x2F;情况三：监视reactive所定义的一个响应式数据，注意，此处无法正确获取oldValuewatch(person,(newValue,oldValue)&#x3D;&gt;{console.log(‘person变化了’);console.log(newValue,oldValue);&#x2F;&#x2F;你会发现这两个的值是一样的}) &#x2F;&#x2F;情况四：监视reactive所定义的一个响应式数据中的某一个属性watch(()&#x3D;&gt;person.job.j1.salary,(newValue,oldValue)&#x3D;&gt;{console.log(‘salary变化了’);console.log(newValue,oldValue);&#x2F;&#x2F;你会发现这两个的值是一样的}) &#x2F;&#x2F;情况五：监视reactive所定义的一个响应式数据中的某些属性watch([()&#x3D;&gt;person.job.j1.salary,()&#x3D;&gt;person.name],(newValue,oldValue)&#x3D;&gt;{console.log(‘salary或者name变化了’);console.log(newValue,oldValue);&#x2F;&#x2F;你会发现这两个的值是一样的}) &#x2F;&#x2F;特殊情况，由于job没有地址上的变化，只是他里面属性发生了变化，所以监视不奏效watch(()&#x3D;&gt;person.job,(newValue,oldValue)&#x3D;&gt;{console.log(‘salary变化了’);console.log(newValue,oldValue);},{deep:true})&#x2F;&#x2F;此处由于监视的是reactive定义的对象的某个属性，deep有效 5.Vue3中的生命周期 6.通过组合式API调用生命周期钩子 在Vue3中，setup会比beforeCreate和created的优先级要高 ，所以使用组合式API的时候，setup已经替代掉这两个生命周期钩子 代码演示 还有一个注意点是：组合式API中的生命周期钩子比配置项钩子先执行 7.自定义hook函数 什么是hook？ ——本值是一个函数，把setup函数中使用的CompositionAPI进行封装 类似vue2.x中的mixin 自定义hook的优势：复用代码，让setup中的逻辑更清楚易懂 8.toRef 作用：创建一个ref对象，其value值指向另一个对象中的某个属性值 语法：const name = toRef(person,&#39;name&#39;) 应用：要将响应式对象中的某个属性单独提供给外部使用时 扩展：toRefs 与 toRef 功能一致，但可以批量创建多个ref对象，语法：toRefs(person) 其他Composition API 1.shallowReactive 与 shallowRef shallowReactive：只处理对象最外层属性的响应式（浅响应式） shallowRef：只处理基本数据类型的响应式，不进行对象的响应式处理 什么时候使用？ 如果有一个对象数据，结构比较深，但变化时只是外层属性变化&#x3D;&#x3D;&gt;shallowReactive 如果有一个对象数据，后续功能不会修改该对象中的属性，而是生成新的对象来替换&#x3D;&#x3D;&gt;shallowRef 2.readonly 与 shallowReadonly readonly:让一个响应式数据变为只读的(深只读)。 shallowReadonly: 让一个响应式数据变为只读的(浅只读) 应用场景:不希望数据被修改时(特别是别人传给你的)。 3.toRaw 与 markRaw toRaw： 作用：将一个由reactive生成的响应式对象转为普通对象 使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的而所有操作，不会引起页面更新 markRaw: 作用： 标记一个对象，使其永远不会在成为响应式对象 应用场景： 有些值不应该被设置为响应式的，例如第三方的复杂类库 当渲染具有不可变的数据源的大列表时，跳过响应式转换可以提高性能 4.customRef 作用：创建一个自定义的ref，对其依赖跟踪和更新触发进行显式控制 实现防抖效果 5.provide 与 inject 作用：实现祖孙组件间的通信(中间隔一个父) 套路：父组件有一个provide选项来提供数据，子组件有一个inject选项来开始使用这些数据 具体写法： 1.祖组件中： 2.孙组件中 6.响应式数据的判断 isRef: 检查一个值是否为一个ref对象 isReactive：检查一个对象是否是由reactive创建的响应式代理 isReadonly：检查一个对象是否是由readonly创建的只读代理 isProxy：检查一个对象是否是由reactive或者readonly 四、Compostion API的优势Options API (Vue2)存在的问题使用传统OptionsAPI中，新增或者修改一个需求，就需要分别在data，methods，computed里修改 。 Composition API (Vue3)的优势我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。 五、新的组件Fragment 在Vue2中: 组件必须有一个根标签 在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中 好处: 减少标签层级, 减小内存占用 Teleport 什么是Teleport？ teleport 是一种能够将我们的 组件html结构 移动到指定位置的技术 Suspense 等待异步组件时渲染一些额外内容，让应用有更好的用户体验 使用步骤： 异步引入组件 使用Suspense包裹组件，并配置好default 与 fallback 六、其他1.全局API的转移 Vue 2.x 有许多全局 API 和配置。 例如：注册全局组件、注册全局指令等。 Vue3.0中对这些API做出了调整： 将全局的API，即：Vue.xxx调整到应用实例（app）上 2.x 全局 API（Vue） 3.x 实例 API (app) Vue.config.xxxx app.config.xxxx Vue.config.productionTip 移除 Vue.component app.component Vue.directive app.directive Vue.mixin app.mixin Vue.use app.use Vue.prototype app.config.globalProperties 2.其他改变 data选项应始终被声明为一个函数。 过度类名的更改： Vue2.x写法 Vue3.x写法 移除keyCode作为 v-on 的修饰符，同时也不再支持config.keyCodes 移除v-on.native修饰符 父组件中绑定事件 子组件中声明自定义事件 移除过滤器（filter） 过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。 "},{"title":"JavaScript ES6 中一些新增的语法","date":"2022-10-10T13:00:14.222Z","url":"/2022/10/10/ES6-11%E4%B8%80%E4%BA%9B%E6%96%B0%E5%A2%9E%E7%9A%84%E8%AF%AD%E6%B3%95/","categories":[["undefined",""]],"content":"JavaScript ES6 中一些新增的语法let let申明的变量只在所处于的块级作用域中有效在一个大括号中，使用let关键字申明的变量才具有块级作用域，var关键字事不具备这个特点的 let的作用防止循环变量变成全局变量 使用var会有变量提升，而使用let就不存在变量提升 使用let关键字申明的变量具有暂时性死区的特性: 经典题型观察下面的代码，判断输出是啥？ 答案是：10 10两次输出的结果都是10，变量i是全局的循环完成之后i11&#x3D;&#x3D;10，所以最终两个都是10 再观察下面的代码，判断输出是啥？ 这种情况，函数调用时候会分别向自己所属的块级作用域中查找i的值，所以输出 0和1每次循环都会产生一个块级作用域，每个块级作用域中的变量都是不同的，函数执行时候是输出自己上一级（循环产生的块级作用域）下的i值 constconst的作用 声明常量，常量就是值（内存地址）不能变化的量和let一样，使用const关键字申明常量具有块级作用域 使用方法使用const 关键字使用const 关键字必须赋初值：const aaa = 111; 常量赋值后，不能修改：const aaa = 111; 对于引用类型来说，const绑定的是引用类型的内存地址，而不是里面的内容: 也就是说 const 对于引用类型来说，绑定的就是引用类型的内存地址，但是里面的内容可以随意更改 使用const创建一个对象 使用const创建对象可以保护对象指向的地址不被篡改 总结let const var 的区别： 使用var声明的变量,其作用域所在的函数内，且存在变量提升的对象 使用let申明的变量，其作用域为该语句所在的代码块内，不存在变量提升 使用const 申明的是常量，在后面出现的代码中，不能再修改该常量的值 Number.EPSILON 与 新增属性Number.EPSILON 是 JavaScript 表示的最小精度 Number.EPSILON 属性表示 1 与Number可表示的大于 1 的最小的浮点数之间的差值。 EPSILON 属性的值接近于 2.2204460492503130808472633361816E-16 先来看一段代码： 所以，就需要用EPSILON来帮忙了 其他的新增属性： Number.isFinite 检测一个数是否为有限数 二进制和八进制 Number.isNaN 检测一个数值是否为NaN Number.parseInt Number.PaseFloat 字符串转为整数 Number.isInteger 判断一个数是否为整数 Math.trunc 将数字的小数部分抹掉 Math.sign 判断一个数到底为正数，复数 还是0 对象方法扩展Object.is意思是判断两个值是否完全相等，和 &#x3D;&#x3D;&#x3D; 运算符差不多，但有区别，例如 Object.assign作用是合并对象(浅拷贝) object.setPrototypeOf作用是设置原型对象（并不建议这么设置） 原始数据类型 SymbolSymbol 的基本使用 ES6引入了一种新的原始数据类型Symbol，表示独一无二的值。它是JavaScript语言的第七种数据类型，是一种类似于字符串的数据类型。简介: ES5的对象属性名都是字符串，这就很容易造成属性名的冲突，比如一个项目很庞大，又不是一个人开发的，就有可能会造成变量名冲突，如果有一个独一无二的名字就好了，这样就能从根本上防止属性名冲突。这就是ES6引入Symbol的原因。 Symbol 特点 Symbol的值是唯一的，用来解决命名冲突的问题 Symbol值不能与其他数据进行运算(包括比较运算) Symbol定义的对象属性不能使用for…in循环遍历，但是可以使用Reflect.ownKeys来获取对象的所有键名 给对象添加 Symbol 类型的属性 解构解构赋值 ES6中允许从数组中提取值，按照对应的位置，对变量赋值，对象也可以实现解构 数组解构 也可以这样写 如果变量没有对应的值，那就为undefined let [a, b, c] = [1, 2]; //c = undefiend 对象解构 对象解构允许我们使用变量的名字匹配对象的属性 匹配成功后将对象属性的值赋值给变量 对象解构的另一种写法: 这里name指kano中的name属性，myName指的是替代这个属性的值的变量 注：修改myName不会影响原对象的name 对象的简化写法ES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法，这样的书写更加简洁 迭代器简介迭代器（Iterator）是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 iterator接口，就可以完成遍历操作 ES6 创造了一种新的遍历命令for…of循环 这个循环主要是使用迭代器进行循环操作的 原生具备迭代器接口的数据（可用for of 遍历） array Arguments Set Map String TypedArray NodeList 工作原理 创建一个指针对象，指向当前数据结构的起始位置 第一次调用对象的next方法，指针自动指向数据结构的第一个成员 接下来不断调用next方法，指针一直往后移动，直到指向最后一个成员 每调用next方法返回一个包含value对象和double属性的对象 迭代器使用 使用 for of 遍历遍历数组 迭代器的应用 生成器生成器函数在可以在执行时能暂停，暂停后又能从暂停处继续执行。 function *yieldyield 关键字用来暂停和恢复一个生成器函数function * 语法 expression 定义通过迭代器协议从生成器函数返回的值。如果省略，则返回undefined。 rv 返回传递给生成器的next()方法的可选值，以恢复其执行。 function * 这种声明方式，会定义一个生成器函数，返回一个 Generator 对象 next方法可以传入实参，传入的实参就是前一个yield语句的整体返回结果 当我们调用第一个next方法后，输出的参数为AAA 第二次调用 输出的为BBB 第三次为 CCC 第四次为 DDD 生成器函数实例当我们想使用异步函数的时候，我们按照以前已有的思想，就是设置一个定时器，setTimeout，通过定时器设置的时差来控制函数的执行顺序 但这样会导致定时器越嵌越多，最终造成一种现象，称之为 回调地狱 代码缩进越来越靠后，可读性越来越差 生成器函数就解决了这样的问题： 解析： 首先创建三个单独的函数，分别存放各自的定时器函数，内部存放有触发遍历的next方法，再创建一个生成器函数gen调用生成器函数使用next方法手动触发第一次遍历，后面的遍历都会自动向后执行，因为我们在每个定时器中依次调用了next方法 生成器函数实例2模拟获取用户数据，订单数据，商品数据 该实例充分利用了next方法可以传入实参作为yield的返回值的特性，实现了异步请求数据的传递，在实际使用中，如果我们需要等待上一个接口完成并返回结果的时候再执行下一步请求，就可以使用生成器函数进行配合操作，同时也避免了回调地狱问题 箭头函数介绍箭头函数是ES6中新增定义函数的方式 () =&gt; &#123;&#125; 这就是一个匿名箭头函数，只不过啥也没干 箭头函数的性质 箭头函数不绑定this关键字，箭头函数中的this指向的是函数声明时所在作用域下的this的值箭头函数不能作为构造实例化对象箭头函数不能使用 arguments 变量 举个栗子： 结果是两个this都指向obj 结论： 箭头函数不绑定this，箭头函数没有自己的关键字 经典例题观察以下代码，看看输出的是啥？ 结果是：输出undefined因为箭头函数没有自己的this，而对象是不能产生作用域的。所以this指向的是window ES6模块化模块化的优点 防止命名冲突 代码复用 高维护性 模块化规范产品ES6 之前的模块化有： CommonJS &#x3D;&gt; NodeJS Browserify AMD &#x3D;&gt; requireJs CMD &#x3D;&gt; seaJS ES6模块化语法模块功能主要由两个命令构成 : exprot 和 import export 命令用于规定模块的对外接口 import 命令用于输入其他模块提供的功能 注意：在浏览器中，import 语句只能在声明了 type=&quot;module&quot; 的 script 的标签中使用。 export模块化可分为 分别暴露 统一暴露 和 默认暴露 例子（分别暴露）JS部分(kano.js)： 例子（统一暴露）JS部分(kano1.js)： 例子（默认暴露）JS部分(kano2.js)： JS入口文件引入 使用JS入口文件引入的模组，在html文档中使用方法如下： HTML引入 kanoMOD是一个module类型，包含了指定文件内标记为暴露（export）的所有实体 以上方法看似很好用，但有些浏览器并不能兼容这种模组引入方式，为了解决兼容性问题，可以使用一个JavaScript编译器—Babel ，，不过我还没系统学习完NodeJS，学完了再回来填坑把 Babel（咕咕咕）剩余(rest)参数介绍 剩余参数允许我们将一个不定数量的参数表示为一个数组，和arguments差不多 语法：...args args为参数 使用方法例子： 使用…args作为剩余参数的标识 剩余参数和解构的配合使用: Array扩展方法扩展运算符 扩展运算符（ spread ）是三个点（…），可以将一个数组转为用逗号分隔的参数序列。扩展运算符可以将数组或者对象转为用逗号分割的参数序列，和剩余参数是反着来的 栗子 …aa 其实就是 ‘a’, ‘b’, ‘c’ 但因为逗号会 被log函数解析为参数列表的分隔符，所以最终输出 a b c 扩展运算符拆解字符串 扩展运算符运用在合并数组操作上 扩展运算符+max方法求最大值 利用扩展运算符将伪数组转换为真正的数组 **特别注意：如果扩展运算符内处理的是类型数据的话，转换的时候使用的是浅拷贝 ** 构造函数方法 ：Array.from() Array.from()方法对一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。 语法： Array.from(arrayLike[, mapFn[, thisArg]]) arrayLike：想要转换成数组的伪数组对象或可迭代对象 mapFn ：如果指定了该参数，新数组中的每个元素会执行该回调函数。 thisArg ：可选参数，执行回调函数 mapFn 时 this 对象 栗子: Array 之 find()方法扩展 Array 之 findIndex 方法 这个方法只会返回第一次遇到的符合条件的元素的下标 Array 之 includes 方法 表示某个数组是否包含指定的值，返回布尔值 String 的扩展方法模板字符串 模板字符串可以解析变量，函数模板字符串需要用 &#96;&#96; 而不是引号模板字符串可以换行 startWith() 和 endsWith() startWith()：表示参数字符串是否在源字符串的头部，返回一个布尔值endsWith()：表示参数字符串是否在源字符串的尾部，返回一个布尔值 repeat() repeat方法表示将源字符串重复n次，返回一个新字符串 Set数据结构 ES6提供了新的数据结构Set，它类似于数组，但是成员的值都是唯一的, 没有重复的值。 set数据结构自动去重 利用set数据结构做数组去重 思路就是，使用set数据结构返回一个不重复的伪数组，再使用扩展运算符打散为逗号分隔的元素，再转换为数组 Set数据结构中的实例方法add(value) :添加某个值，返回Set结构本身 delete(value) :删除某个值，返回一个布尔值，表示删除是否成功 has(value) :返回一个布尔值，表示该值是否为Set的成员 clear() :清除所有成员，没有返回值 使用例: set数据结构中的遍历 set结构的实例与数组一样，也有forEach方法，用于对每个成员执行某种操作，没有返回值。 Map数据结构ES6提供了Map数据结构。它类似于对象，也是键值对的集合。但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。Map也实现了iterator接口，所以可以使用『扩展运算符』和『 for…of…』进行遍历。 Map的属性和方法: size 返回Map的元素个数 set 增加一个元素，返回当前map get 返回键名对象的键值 has 检测Map中是否包含某个元素，返回boolean值 clear 清空集合， 返回undefined 创建一个空Map map属性和方法的使用 Getter 与 Setter**get**语法将对象属性绑定到查询该属性时将被调用的函数。 当尝试设置属性时，**set**语法将对象属性绑定到要调用的函数。 ES6之Promise(不完整，到时候再补充)Promise介绍Promise 是 ES6 引入的异步编程的新的语法糖，在语法上，Promise 是一个构造函数，用来封装异步操作，并可以获取成功或者失败的结果 一个promise请求会有以下几种状态： 待定（pending）：初始状态，既没有被兑现，也没有被拒绝。 已兑现（fulfilled）：意味着操作成功完成。 已拒绝（rejected）：意味着操作失败。 Promise 还有一个好处就是 支持链式调用，传统回调函数会嵌套调用，外部回调函数异步执行的结果是嵌套的回调执行条件，造成回调地狱，这样的代码既不方便阅读，也不便与异常处理，这就催生了promise的出现 Promise 的使用先简单的看一个Promise的实例方法： ES7中新增的语法includes**includes()** 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回 false。 ES8中新增的语法async 和 await async 和 await 两种语法结合可以让异步代码像同步代码一样 async 函数 async h函数的返回值为promise对象 promise 对象的结果由async函数执行的返回值决定 例子 await 表达式 - 异步编程的完美解决方案规则 await 必须写在 async 函数中 await 右侧的表达式一般为promise对象 await返回的是primise成功的值 await 的promise 失败了，就会抛出异常，需要通过 try catch 捕获处理 例子 async 和 await 组合实现 Ajax 请求 对象方法扩展(ES8)Object.values 和 Object.entries Object.values()方法返回一个给定对象的所有可枚举属性值的数组 Object.entries() 方法返回一个给定对象自身可遍历属性[key,value] 的数组 作用 可以用来创建一个Map: Object.getOwnPropertyDescriptors该方法返回指定对象所有 自身属性 的描述对象 上面的输出和我们使用Object.create()方法中操作的属性是一样的: ES9中新增的语法扩展运算符和rest参数 Rest 参数与 spread 扩展运算符在ES6 中已经被引入，不过ES6中的只针对于数组 在ES9 中为对象提供了像数组一样的rest参数和扩展运算符 正则扩展命名捕获分组 像上面一样，在正则表达式内加入命名捕获分组 ?&lt;url&gt; ?&lt;text&gt; 这样就可以在exec后返回的对象中产生一个groups属性，跟方便我们提取有关的字符串 正向断言（先行断言） 这里的?=就是正向断言，意思是，要满足等号后面的条件，前件才为真 翻译一下就是：仅当这串数字后面跟着d才匹配这串数字 反向断言（后行断言） 这里的?&lt;=kano就是反向断言，意思是，要满足等号前面的条件，后件才为真 dotAll 模式dot 也就是 “ . “ 元字符 可以匹配除换行符以外的任意单个字符 注意，这里的 ？的意义是： 如果 ? 紧跟在任何量词 *、 +、? 或 {} 的后面，将会使量词变为非贪婪（匹配尽量少的字符），和缺省使用的贪婪模式（匹配尽可能多的字符）正好相反。例如，对 “123abc” 使用 /\\d+/ 将会匹配 “123”，而使用 /\\d+?/ 则只会匹配到 “1”。 ES10中新增的语法Object.fromEntries这个对应es8里面的Object.entries() 和Object.entries()相反，Object.fromEntries是将二维数组转换为对象 trimStart与trimEnd和语义一样，是trim的扩展细分 trimStart 去掉字符串前端的空格 trimEnd 去掉字符串后端的空格 flat 与flatMapFlat是平的意思 flat是将多维数组转换成一维数组 flatMap() 方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。 Symbol.prototype.description ES11中新增的语法私有属性 注意，私有属性不能定义在类的外面 Promise.allSettledPromise.allSettled()方法返回一个在所有给定的 promise 都已经fulfilled或rejected后的 promise，并带有一个对象数组，每个对象表示对应的 promise 结果。 也就是，返回一个成功的promise ，里面装着给定的promise的执行结果 当您有多个彼此不依赖的异步任务成功完成时，或者您总是想知道每个promise的结果时，通常使用它。 于此类似的Primose.all方法，则是在p1，p2都成功的时候返回的Promise才是成功的，否则为失败的Promise String.prototype.matchAll这个方法挺实用的，用于数据的批量提取 方法返回的是一个可迭代对象 可选链操作符可选链操作符，即 ?. 作用是判断前面的对象是否存在有效，有效则执行里面的属性操作 bigint类型也叫大整形，在普通整形基础后加一个n 用于大数值运算 绝对全局对象globalThis"},{"title":"Hello World","date":"2022-10-10T12:41:44.938Z","url":"/2022/10/10/hello-world/","categories":[["undefined",""]],"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post More info: Writing Run server More info: Server Generate static files More info: Generating Deploy to remote sites More info: Deployment"}]