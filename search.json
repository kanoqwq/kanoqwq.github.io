[{"title":"JavaScript ES6 中一些新增的语法","date":"2022-10-10T13:00:14.222Z","url":"/2022/10/10/ES6-11%E4%B8%80%E4%BA%9B%E6%96%B0%E5%A2%9E%E7%9A%84%E8%AF%AD%E6%B3%95/","categories":[["undefined",""]],"content":"JavaScript ES6 中一些新增的语法let let申明的变量只在所处于的块级作用域中有效在一个大括号中，使用let关键字申明的变量才具有块级作用域，var关键字事不具备这个特点的 let的作用防止循环变量变成全局变量 使用var会有变量提升，而使用let就不存在变量提升 使用let关键字申明的变量具有暂时性死区的特性: 经典题型观察下面的代码，判断输出是啥？ 答案是：10 10两次输出的结果都是10，变量i是全局的循环完成之后i11&#x3D;&#x3D;10，所以最终两个都是10 再观察下面的代码，判断输出是啥？ 这种情况，函数调用时候会分别向自己所属的块级作用域中查找i的值，所以输出 0和1每次循环都会产生一个块级作用域，每个块级作用域中的变量都是不同的，函数执行时候是输出自己上一级（循环产生的块级作用域）下的i值 constconst的作用 声明常量，常量就是值（内存地址）不能变化的量和let一样，使用const关键字申明常量具有块级作用域 使用方法使用const 关键字使用const 关键字必须赋初值：const aaa = 111; 常量赋值后，不能修改：const aaa = 111; 对于引用类型来说，const绑定的是引用类型的内存地址，而不是里面的内容: 也就是说 const 对于引用类型来说，绑定的就是引用类型的内存地址，但是里面的内容可以随意更改 使用const创建一个对象 使用const创建对象可以保护对象指向的地址不被篡改 总结let const var 的区别： 使用var声明的变量,其作用域所在的函数内，且存在变量提升的对象 使用let申明的变量，其作用域为该语句所在的代码块内，不存在变量提升 使用const 申明的是常量，在后面出现的代码中，不能再修改该常量的值 Number.EPSILON 与 新增属性Number.EPSILON 是 JavaScript 表示的最小精度 Number.EPSILON 属性表示 1 与Number可表示的大于 1 的最小的浮点数之间的差值。 EPSILON 属性的值接近于 2.2204460492503130808472633361816E-16 先来看一段代码： 所以，就需要用EPSILON来帮忙了 其他的新增属性： Number.isFinite 检测一个数是否为有限数 二进制和八进制 Number.isNaN 检测一个数值是否为NaN Number.parseInt Number.PaseFloat 字符串转为整数 Number.isInteger 判断一个数是否为整数 Math.trunc 将数字的小数部分抹掉 Math.sign 判断一个数到底为正数，复数 还是0 对象方法扩展Object.is意思是判断两个值是否完全相等，和 &#x3D;&#x3D;&#x3D; 运算符差不多，但有区别，例如 Object.assign作用是合并对象(浅拷贝) object.setPrototypeOf作用是设置原型对象（并不建议这么设置） 原始数据类型 SymbolSymbol 的基本使用 ES6引入了一种新的原始数据类型Symbol，表示独一无二的值。它是JavaScript语言的第七种数据类型，是一种类似于字符串的数据类型。简介: ES5的对象属性名都是字符串，这就很容易造成属性名的冲突，比如一个项目很庞大，又不是一个人开发的，就有可能会造成变量名冲突，如果有一个独一无二的名字就好了，这样就能从根本上防止属性名冲突。这就是ES6引入Symbol的原因。 Symbol 特点 Symbol的值是唯一的，用来解决命名冲突的问题 Symbol值不能与其他数据进行运算(包括比较运算) Symbol定义的对象属性不能使用for…in循环遍历，但是可以使用Reflect.ownKeys来获取对象的所有键名 给对象添加 Symbol 类型的属性 解构解构赋值 ES6中允许从数组中提取值，按照对应的位置，对变量赋值，对象也可以实现解构 数组解构 也可以这样写 如果变量没有对应的值，那就为undefined let [a, b, c] = [1, 2]; //c = undefiend 对象解构 对象解构允许我们使用变量的名字匹配对象的属性 匹配成功后将对象属性的值赋值给变量 对象解构的另一种写法: 这里name指kano中的name属性，myName指的是替代这个属性的值的变量 注：修改myName不会影响原对象的name 对象的简化写法ES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法，这样的书写更加简洁 迭代器简介迭代器（Iterator）是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 iterator接口，就可以完成遍历操作 ES6 创造了一种新的遍历命令for…of循环 这个循环主要是使用迭代器进行循环操作的 原生具备迭代器接口的数据（可用for of 遍历） array Arguments Set Map String TypedArray NodeList 工作原理 创建一个指针对象，指向当前数据结构的起始位置 第一次调用对象的next方法，指针自动指向数据结构的第一个成员 接下来不断调用next方法，指针一直往后移动，直到指向最后一个成员 每调用next方法返回一个包含value对象和double属性的对象 迭代器使用 使用 for of 遍历遍历数组 迭代器的应用 生成器生成器函数在可以在执行时能暂停，暂停后又能从暂停处继续执行。 function *yieldyield 关键字用来暂停和恢复一个生成器函数function * 语法 expression 定义通过迭代器协议从生成器函数返回的值。如果省略，则返回undefined。 rv 返回传递给生成器的next()方法的可选值，以恢复其执行。 function * 这种声明方式，会定义一个生成器函数，返回一个 Generator 对象 next方法可以传入实参，传入的实参就是前一个yield语句的整体返回结果 当我们调用第一个next方法后，输出的参数为AAA 第二次调用 输出的为BBB 第三次为 CCC 第四次为 DDD 生成器函数实例当我们想使用异步函数的时候，我们按照以前已有的思想，就是设置一个定时器，setTimeout，通过定时器设置的时差来控制函数的执行顺序 但这样会导致定时器越嵌越多，最终造成一种现象，称之为 回调地狱 代码缩进越来越靠后，可读性越来越差 生成器函数就解决了这样的问题： 解析： 首先创建三个单独的函数，分别存放各自的定时器函数，内部存放有触发遍历的next方法，再创建一个生成器函数gen调用生成器函数使用next方法手动触发第一次遍历，后面的遍历都会自动向后执行，因为我们在每个定时器中依次调用了next方法 生成器函数实例2模拟获取用户数据，订单数据，商品数据 该实例充分利用了next方法可以传入实参作为yield的返回值的特性，实现了异步请求数据的传递，在实际使用中，如果我们需要等待上一个接口完成并返回结果的时候再执行下一步请求，就可以使用生成器函数进行配合操作，同时也避免了回调地狱问题 箭头函数介绍箭头函数是ES6中新增定义函数的方式 () =&gt; &#123;&#125; 这就是一个匿名箭头函数，只不过啥也没干 箭头函数的性质 箭头函数不绑定this关键字，箭头函数中的this指向的是函数声明时所在作用域下的this的值箭头函数不能作为构造实例化对象箭头函数不能使用 arguments 变量 举个栗子： 结果是两个this都指向obj 结论： 箭头函数不绑定this，箭头函数没有自己的关键字 经典例题观察以下代码，看看输出的是啥？ 结果是：输出undefined因为箭头函数没有自己的this，而对象是不能产生作用域的。所以this指向的是window ES6模块化模块化的优点 防止命名冲突 代码复用 高维护性 模块化规范产品ES6 之前的模块化有： CommonJS &#x3D;&gt; NodeJS Browserify AMD &#x3D;&gt; requireJs CMD &#x3D;&gt; seaJS ES6模块化语法模块功能主要由两个命令构成 : exprot 和 import export 命令用于规定模块的对外接口 import 命令用于输入其他模块提供的功能 注意：在浏览器中，import 语句只能在声明了 type=&quot;module&quot; 的 script 的标签中使用。 export模块化可分为 分别暴露 统一暴露 和 默认暴露 例子（分别暴露）JS部分(kano.js)： 例子（统一暴露）JS部分(kano1.js)： 例子（默认暴露）JS部分(kano2.js)： JS入口文件引入 使用JS入口文件引入的模组，在html文档中使用方法如下： HTML引入 kanoMOD是一个module类型，包含了指定文件内标记为暴露（export）的所有实体 以上方法看似很好用，但有些浏览器并不能兼容这种模组引入方式，为了解决兼容性问题，可以使用一个JavaScript编译器—Babel ，，不过我还没系统学习完NodeJS，学完了再回来填坑把 Babel（咕咕咕）剩余(rest)参数介绍 剩余参数允许我们将一个不定数量的参数表示为一个数组，和arguments差不多 语法：...args args为参数 使用方法例子： 使用…args作为剩余参数的标识 剩余参数和解构的配合使用: Array扩展方法扩展运算符 扩展运算符（ spread ）是三个点（…），可以将一个数组转为用逗号分隔的参数序列。扩展运算符可以将数组或者对象转为用逗号分割的参数序列，和剩余参数是反着来的 栗子 …aa 其实就是 ‘a’, ‘b’, ‘c’ 但因为逗号会 被log函数解析为参数列表的分隔符，所以最终输出 a b c 扩展运算符拆解字符串 扩展运算符运用在合并数组操作上 扩展运算符+max方法求最大值 利用扩展运算符将伪数组转换为真正的数组 **特别注意：如果扩展运算符内处理的是类型数据的话，转换的时候使用的是浅拷贝 ** 构造函数方法 ：Array.from() Array.from()方法对一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。 语法： Array.from(arrayLike[, mapFn[, thisArg]]) arrayLike：想要转换成数组的伪数组对象或可迭代对象 mapFn ：如果指定了该参数，新数组中的每个元素会执行该回调函数。 thisArg ：可选参数，执行回调函数 mapFn 时 this 对象 栗子: Array 之 find()方法扩展 Array 之 findIndex 方法 这个方法只会返回第一次遇到的符合条件的元素的下标 Array 之 includes 方法 表示某个数组是否包含指定的值，返回布尔值 String 的扩展方法模板字符串 模板字符串可以解析变量，函数模板字符串需要用 &#96;&#96; 而不是引号模板字符串可以换行 startWith() 和 endsWith() startWith()：表示参数字符串是否在源字符串的头部，返回一个布尔值endsWith()：表示参数字符串是否在源字符串的尾部，返回一个布尔值 repeat() repeat方法表示将源字符串重复n次，返回一个新字符串 Set数据结构 ES6提供了新的数据结构Set，它类似于数组，但是成员的值都是唯一的, 没有重复的值。 set数据结构自动去重 利用set数据结构做数组去重 思路就是，使用set数据结构返回一个不重复的伪数组，再使用扩展运算符打散为逗号分隔的元素，再转换为数组 Set数据结构中的实例方法add(value) :添加某个值，返回Set结构本身 delete(value) :删除某个值，返回一个布尔值，表示删除是否成功 has(value) :返回一个布尔值，表示该值是否为Set的成员 clear() :清除所有成员，没有返回值 使用例: set数据结构中的遍历 set结构的实例与数组一样，也有forEach方法，用于对每个成员执行某种操作，没有返回值。 Map数据结构ES6提供了Map数据结构。它类似于对象，也是键值对的集合。但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。Map也实现了iterator接口，所以可以使用『扩展运算符』和『 for…of…』进行遍历。 Map的属性和方法: size 返回Map的元素个数 set 增加一个元素，返回当前map get 返回键名对象的键值 has 检测Map中是否包含某个元素，返回boolean值 clear 清空集合， 返回undefined 创建一个空Map map属性和方法的使用 Getter 与 Setter**get**语法将对象属性绑定到查询该属性时将被调用的函数。 当尝试设置属性时，**set**语法将对象属性绑定到要调用的函数。 ES6之Promise(不完整，到时候再补充)Promise介绍Promise 是 ES6 引入的异步编程的新的语法糖，在语法上，Promise 是一个构造函数，用来封装异步操作，并可以获取成功或者失败的结果 一个promise请求会有以下几种状态： 待定（pending）：初始状态，既没有被兑现，也没有被拒绝。 已兑现（fulfilled）：意味着操作成功完成。 已拒绝（rejected）：意味着操作失败。 Promise 还有一个好处就是 支持链式调用，传统回调函数会嵌套调用，外部回调函数异步执行的结果是嵌套的回调执行条件，造成回调地狱，这样的代码既不方便阅读，也不便与异常处理，这就催生了promise的出现 Promise 的使用先简单的看一个Promise的实例方法： ES7中新增的语法includes**includes()** 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回 false。 ES8中新增的语法async 和 await async 和 await 两种语法结合可以让异步代码像同步代码一样 async 函数 async h函数的返回值为promise对象 promise 对象的结果由async函数执行的返回值决定 例子 await 表达式 - 异步编程的完美解决方案规则 await 必须写在 async 函数中 await 右侧的表达式一般为promise对象 await返回的是primise成功的值 await 的promise 失败了，就会抛出异常，需要通过 try catch 捕获处理 例子 async 和 await 组合实现 Ajax 请求 对象方法扩展(ES8)Object.values 和 Object.entries Object.values()方法返回一个给定对象的所有可枚举属性值的数组 Object.entries() 方法返回一个给定对象自身可遍历属性[key,value] 的数组 作用 可以用来创建一个Map: Object.getOwnPropertyDescriptors该方法返回指定对象所有 自身属性 的描述对象 上面的输出和我们使用Object.create()方法中操作的属性是一样的: ES9中新增的语法扩展运算符和rest参数 Rest 参数与 spread 扩展运算符在ES6 中已经被引入，不过ES6中的只针对于数组 在ES9 中为对象提供了像数组一样的rest参数和扩展运算符 正则扩展命名捕获分组 像上面一样，在正则表达式内加入命名捕获分组 ?&lt;url&gt; ?&lt;text&gt; 这样就可以在exec后返回的对象中产生一个groups属性，跟方便我们提取有关的字符串 正向断言（先行断言） 这里的?=就是正向断言，意思是，要满足等号后面的条件，前件才为真 翻译一下就是：仅当这串数字后面跟着d才匹配这串数字 反向断言（后行断言） 这里的?&lt;=kano就是反向断言，意思是，要满足等号前面的条件，后件才为真 dotAll 模式dot 也就是 “ . “ 元字符 可以匹配除换行符以外的任意单个字符 注意，这里的 ？的意义是： 如果 ? 紧跟在任何量词 *、 +、? 或 {} 的后面，将会使量词变为非贪婪（匹配尽量少的字符），和缺省使用的贪婪模式（匹配尽可能多的字符）正好相反。例如，对 “123abc” 使用 /\\d+/ 将会匹配 “123”，而使用 /\\d+?/ 则只会匹配到 “1”。 ES10中新增的语法Object.fromEntries这个对应es8里面的Object.entries() 和Object.entries()相反，Object.fromEntries是将二维数组转换为对象 trimStart与trimEnd和语义一样，是trim的扩展细分 trimStart 去掉字符串前端的空格 trimEnd 去掉字符串后端的空格 flat 与flatMapFlat是平的意思 flat是将多维数组转换成一维数组 flatMap() 方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。 Symbol.prototype.description ES11中新增的语法私有属性 注意，私有属性不能定义在类的外面 Promise.allSettledPromise.allSettled()方法返回一个在所有给定的 promise 都已经fulfilled或rejected后的 promise，并带有一个对象数组，每个对象表示对应的 promise 结果。 也就是，返回一个成功的promise ，里面装着给定的promise的执行结果 当您有多个彼此不依赖的异步任务成功完成时，或者您总是想知道每个promise的结果时，通常使用它。 于此类似的Primose.all方法，则是在p1，p2都成功的时候返回的Promise才是成功的，否则为失败的Promise String.prototype.matchAll这个方法挺实用的，用于数据的批量提取 方法返回的是一个可迭代对象 可选链操作符可选链操作符，即 ?. 作用是判断前面的对象是否存在有效，有效则执行里面的属性操作 bigint类型也叫大整形，在普通整形基础后加一个n 用于大数值运算 绝对全局对象globalThis"},{"title":"Hello World","date":"2022-10-10T12:41:44.938Z","url":"/2022/10/10/hello-world/","categories":[["undefined",""]],"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post More info: Writing Run server More info: Server Generate static files More info: Generating Deploy to remote sites More info: Deployment"}]